---
title: "Hauser_Tests"
author: "Emma Hauser"
params:
  today: !r.Sys.Date
output: html_document
---
##Tests for data_import function

```{r Data_Import_sourced, echo=T}
source("Data_Import_Function.R")
```

###Test if data_import makes data.frame objects in the environment 
```{r DataImport_Test, echo=TRUE}
numsets <- 2 #If I try to import 2 datasets, the import function should bring in 2 new objects. There will be other objects in the enviroment that come with the function, but always more than the number of datasets.
NameOfWorkingDir <- "~/Google Drive/KU Info/Spring 2018/DataCapentry_EnvironmentalInformatics/hauser_finalProject"
test <- data_import(NameOfWorkingDir)
if(length(ls()) > numsets )
{
  print("passed")
}else
{
  print("failed")
}
```

##Test for Data_fill function and Data Extrapolation

```{r Data_Extrapolate_sourced, echo=T}
source("Data_Extrapolate_Function.R")
PoFra <- read.csv("PoFract.csv")
EOC.c <- read.csv("EOC.csv")
```

###Test that function produces a dataframe with response variables calculated every centimeter to 2 meters soil depth

```{r data_fill_1, echo=T}
ExpectDatRows <- 172
ExpectDatCols <- 5
SoilSummDat <- as.data.frame(4:175)
colnames(SoilSummDat) <- "Depth"
SoilSummDat$Po <- data_fill(PoFra, datReturn = F)  #These use 2 datasets from import above to make a new dataframe with interpolated values. There should be a column for each set of values in the dataframe. This tests that the data_fill function works correctly.
SoilSummDat$EOC <- data_fill(EOC.c, datReturn =F)
#Check columns
if(ncol(SoilSummDat) == ExpectDatCols)
{
  print("passed")
}else
{
  print("failed")
}


#Check rows
if(nrow(SoilSummDat) == ExpectDatRows)
{
  print("passed")
}else
{
  print("failed")
}

```


##Tests for soil_stats function

```{r soil_stats_sourced, echo=T}
source("Soil_Stats_function.R")
#Make simple dataframe with soil_stats_simple
SoilSummDat <- as.data.frame(4:175)
colnames(SoilSummDat) <- "Depth"
SoilSummDat$Po <- data_fill(PoFra, datReturn = T)
SoilSummDat$EOC <- data_fill(EOC.c, datReturn = T)
soildat <- SoilSummDat[42:172, ]
```

###Test that soil_stats calculates realistic correlation value

```{r soil_stats, echo=TRUE}
correlRangeMin <- -1
correlRangeMax <- 1
testStats3 <- soil_stats_simple(var1 = soildat$Po, var2 = soildat$EOC)
if(testStats3$p.value > correlRangeMin && testStats3$p.value < correlRangeMax)
{
  print("passed")
}else
{
  print("failed")
}
```

<!-- ##Tests for soil_plot function
I am planning to learn additional plotting in ggplot/ggplot2 for future analyses. For now, I'm keeping things simple for my proposal and making plots though base R to show preliminary data. Once I learn ggplot graphing capabilities, I may need the following unit tests: -->

<!--```{r Soil_plot_sourced, echo=T}
source("SoilDataPlottingFunction.R")
install.packages("testthat")
library(testthat) #This test will make use of the testthat package and function, which is used for examining plot elements and expectations, particularly for graphs produced in ggplot2 
``` -->



<!--###Test that soil_plot function returns a ggplot object -->

<!--```{r soil_plot_1, echo=TRUE}
testplot <- soil_plot(test)

#test_that("Plot returns ggplot object",
#{
#Passes
  #expect_is(testplot,"ggplot")
#})

#The testthat() function returns red numbered "Failure" messages with description of the problem when expectation is not met. If the test passes, the function displays a green dot. 
#Resource for this function: https://journal.r-project.org/archive/2011/RJ-2011-002/RJ-2011-002.pdf
```-->


<!--###Test that soil_plot function uses correct data-->

<!--```{r soil_plot_2, echo=TRUE}
testplot2 <- soil_plot(test)

#test_that("Plot uses correct data", 
#{
  #Passes
  #expect_that(testplot2, equals(test$responseData))
#})

```-->

